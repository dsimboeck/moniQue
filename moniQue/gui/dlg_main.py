# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MoniQueDialog
                                 A QGIS plugin
 Monoplotting oblique images.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-02-07
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Sebastian Mikolka-Fl√∂ry
        email                : s.floery@gmx.at
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import time
from qgis.PyQt import QtWidgets, QtCore, QtGui
from qgis.gui import QgsMapCanvas, QgsRubberBand
from wgpu.gui.qt import WgpuCanvas
from wgpu.gui.offscreen import WgpuCanvas as offscreenCanvas
import pygfx as gfx
import open3d as o3d
import numpy as np
# import imageio.v3 as iio
from PIL import Image
from osgeo import gdal
import json
import sys
import urllib.request
import glob
import copy
import webbrowser

from collections import OrderedDict
from qgis.utils import iface

from qgis.core import (QgsFeature,
                       QgsField,
                       QgsVectorLayer, 
                       QgsVectorFileWriter,
                       QgsPoint, 
                       QgsRasterLayer, 
                       QgsProject, 
                       QgsJsonUtils, 
                       QgsGeometry, 
                       QgsCoordinateReferenceSystem, 
                       QgsCoordinateTransform, 
                       Qgis, 
                       QgsPointXY)

from qgis.gui import QgsMapToolPan
from qgis.PyQt.QtWidgets import QFileDialog

from PyQt5.QtGui import QColor, QCursor, QFont
from PyQt5.QtCore import Qt

# from .dlg_create import CreateDialog
from .dlg_orient import OrientDialog
from .dlg_meta_gcp import GcpMetaDialog
# from .dlg_meta_export import ExportMetaDialog
# from .dlg_import_akon import ImportAkonDialog
from .dlg_meta_mono import MonoMetaDialog
from ..tools.ImgPickerTool import ImgPickerTool
from ..tools.MonoMapTool import MonoMapTool
from ..tools.SelectTool import SelectTool
from ..tools.VertexTool import VertexTool
from ..tools.jsonImport import jsonImport

from ..camera import Camera
from ..helpers import create_point_3d, rot2alzeka, alzeka2rot, calc_hfov, calc_vfov

from ..tools.map_controller import OrbitFlightController
from ..tools.img_controller import ImageController

class MainDialog(QtWidgets.QDialog):
    
    load_project_signal = QtCore.pyqtSignal(object)
    close_dialog_signal = QtCore.pyqtSignal()
    
    def __init__(self, parent=None, plugin_dir=None):
        """Constructor."""
        super(MainDialog, self).__init__()
        
        self.setFont(QFont("Sans Serif", 10))

        self.parent = parent
        self.msg_bar = self.parent.iface.messageBar()
        self.plugin_dir = plugin_dir
        self.icon_dir = os.path.join(self.plugin_dir, "gfx", "icon")
        
        #will be set from monique.py
        self.camera_collection = None
        self.tiles_data = None
        self.initial_render = True
        self.project_pos_toggled = False
        self.temporary_camera = None
        self.orient_dlg_open = False
        
        self.setWindowTitle("moniQue")
        self.setWindowFlag(QtCore.Qt.WindowMaximizeButtonHint, True)
        self.setWindowIcon(QtGui.QIcon(os.path.join(self.plugin_dir, "icon.png")))

        self.menu = QtWidgets.QMenuBar(self)
        self.file_menu = QtWidgets.QMenu("&File", self)
        self.menu.addMenu(self.file_menu)
        
        self.img_menu = QtWidgets.QMenu("&Images", self)
        self.img_menu.setEnabled(False)
        self.menu.addMenu(self.img_menu)

        # self.export_menu = QtWidgets.QMenu("&Export", self)
        # self.export_menu.setEnabled(False)
        # self.menu.addMenu(self.export_menu)

        # self.view_menu = QtWidgets.QMenu("&View", self)
        # self.view_menu.setEnabled(False)
        # self.menu.addMenu(self.view_menu)
        
        self.create_action = QtWidgets.QAction("&Create from *.json", self)
        self.create_action.triggered.connect(self.show_dlg_create)
        self.file_menu.addAction(self.create_action)
        
        self.load_action = QtWidgets.QAction("&Load project", self)
        self.load_action.triggered.connect(self.load_project)
        self.file_menu.addAction(self.load_action)
                
        self.import_action = QtWidgets.QAction("&Import images", self)
        self.import_action.triggered.connect(self.import_images)
        self.img_menu.addAction(self.import_action)

        self.import_json_action = QtWidgets.QAction("&Import initial orientation from *.json", self)
        self.import_json_action.triggered.connect(self.import_json)
        self.img_menu.addAction(self.import_json_action)

        # self.export_action = QtWidgets.QAction("&Export Object View to PNG", self)
        # self.export_action.triggered.connect(self.export_obj_canvas)
        # self.export_menu.addAction(self.export_action)

        self.main_toolbar = QtWidgets.QToolBar("Main toolbar")
        self.main_toolbar.setIconSize(QtCore.QSize(24, 24))

        self.btn_ori_tool = QtWidgets.QAction("Open orientation dialog", self)
        self.btn_ori_tool.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "open_orientation_dialog.png")))
        self.btn_ori_tool.triggered.connect(self.show_dlg_orient)
        self.btn_ori_tool.setCheckable(True)
        self.btn_ori_tool.setEnabled(False)
        self.main_toolbar.addAction(self.btn_ori_tool)
        
        self.main_toolbar.addSeparator()
        
        self.btn_mono_tool = QtWidgets.QAction("Activate monoplotting tool", self)
        self.btn_mono_tool.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "mActionAddPolyline.png")))
        self.btn_mono_tool.setEnabled(False)
        self.btn_mono_tool.setCheckable(True)
        self.btn_mono_tool.triggered.connect(self.toggle_mono_tool)
        self.main_toolbar.addAction(self.btn_mono_tool)
        
        self.btn_mono_select = QtWidgets.QAction("Select monoplotted lines", self)
        self.btn_mono_select.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "mActionSelectRectangle.png")))
        self.btn_mono_select.setEnabled(False)
        self.btn_mono_select.setCheckable(True)
        self.btn_mono_select.triggered.connect(self.toggle_mono_select_tool)
        self.main_toolbar.addAction(self.btn_mono_select)
        
        self.btn_mono_vertex = QtWidgets.QAction("Edit monoplotted lines", self)
        self.btn_mono_vertex.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "mActionVertexToolActiveLayer.png")))
        self.btn_mono_vertex.setEnabled(False)
        self.btn_mono_vertex.setCheckable(True)
        self.btn_mono_vertex.triggered.connect(self.toggle_mono_vertex_tool)
        self.main_toolbar.addAction(self.btn_mono_vertex)

        self.main_toolbar.addSeparator()
        
        spacer = QtWidgets.QWidget()
        spacer.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        self.main_toolbar.addWidget(spacer)
        
        self.main_toolbar.addSeparator()
        
        self.btn_open_help = QtWidgets.QAction("Open documentation on GitHub.", self)
        self.btn_open_help.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "help_icon.png")))
        self.btn_open_help.triggered.connect(self.open_help_window)
        self.main_toolbar.addAction(self.btn_open_help)

        
        self.img_toolbar = QtWidgets.QToolBar()
        self.img_toolbar.setIconSize(QtCore.QSize(24, 24))
        
        self.img_canvas = QgsMapCanvas(parent=self)
        self.img_canvas.setMinimumSize(QtCore.QSize(300, 16777215))
        
        self.img_statusbar = QtWidgets.QStatusBar()
        self.img_statusbar.setFixedHeight(24)
        # self.img_text = QtWidgets.QLabel()
        # self.img_text.setText("Dummy/Dummy")
        # self.img_statusbar.addWidget(self.img_text)
        
        self.img_pan_tool = QgsMapToolPan(self.img_canvas)
        self.mono_tool = MonoMapTool(self.img_canvas, self.parent.map_canvas, MonoMetaDialog())
        self.mono_vertex_tool = VertexTool(self.img_canvas, self.parent.map_canvas)
        self.mono_select_tool = SelectTool(self.img_canvas)
        
        btn_img_pan = QtWidgets.QAction("Pan (Image)", self)
        btn_img_pan.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "mActionPan.png")))
        btn_img_pan.setCheckable(True)
        self.img_toolbar.addAction(btn_img_pan)
        
        btn_img_extent = QtWidgets.QAction("Zoom to image extent.", self)
        btn_img_extent.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "mActionZoomFullExtent.png")))
        btn_img_extent.triggered.connect(self.set_img_canvas_extent)
        self.img_toolbar.addAction(btn_img_extent)
        
        self.obj_toolbar = QtWidgets.QToolBar()
        self.obj_toolbar.setIconSize(QtCore.QSize(24, 24))

        self.obj_canvas = WgpuCanvas(parent=self)
        self.obj_canvas.setMinimumSize(QtCore.QSize(300, 16777215))

        self.obj_statusbar = QtWidgets.QStatusBar()
        self.obj_statusbar.setFixedHeight(24)
        
        self.obj_status_fov = QtWidgets.QLabel()
        self.obj_status_fov.setText("FOV")
        self.obj_status_fov_edit = QtWidgets.QLineEdit()
        self.obj_status_fov_edit.setEnabled(False)
        self.obj_status_fov_edit.setFixedWidth(35)
        self.obj_status_fov_edit.setFixedHeight(20)
        self.obj_statusbar.addWidget(self.obj_status_fov)
        self.obj_statusbar.addWidget(self.obj_status_fov_edit)
        
        self.btn_reset_obj_canvas_camera = QtWidgets.QAction("Reset to default camera position.", self)
        self.btn_reset_obj_canvas_camera.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "zoom_to_extent.png")))
        self.btn_reset_obj_canvas_camera.triggered.connect(self.reset_obj_canvas_camera)
        self.btn_reset_obj_canvas_camera.setEnabled(False)
        self.obj_toolbar.addAction(self.btn_reset_obj_canvas_camera)

        self.btn_obj_canvas_camera_from_map = QtWidgets.QAction("Set camera to current QGIS canvas extent.", self)
        self.btn_obj_canvas_camera_from_map.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "mExtentFromMap.png")))
        self.btn_obj_canvas_camera_from_map.triggered.connect(self.obj_canvas_camera_from_map)
        self.btn_obj_canvas_camera_from_map.setEnabled(False)
        self.obj_toolbar.addAction(self.btn_obj_canvas_camera_from_map)
        
        self.obj_toolbar.addSeparator()
        
        self.btn_obj_canvas_show_img = QtWidgets.QAction("Show image in 3D canvas.", self)
        self.btn_obj_canvas_show_img.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "add_image_to_3d_canvas.png")))
        self.btn_obj_canvas_show_img.triggered.connect(self.show_img_in_obj_canvas)
        self.btn_obj_canvas_show_img.setEnabled(False)
        self.btn_obj_canvas_show_img.setCheckable(True)
        self.obj_toolbar.addAction(self.btn_obj_canvas_show_img)

        self.btn_show_cam_pos = QtWidgets.QAction("Show/hide camera in 3D Canvas", self)
        self.btn_show_cam_pos.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "hide_view_camera_3d.png")))
        self.btn_show_cam_pos.triggered.connect(self.show_cam_pos)
        self.btn_show_cam_pos.setEnabled(False)
        self.btn_show_cam_pos.setCheckable(True)
        self.obj_toolbar.addAction(self.btn_show_cam_pos)

        self.obj_toolbar.addSeparator()

        self.btn_save_obj_canvas_camera = QtWidgets.QAction("Save camera position.", self)
        self.btn_save_obj_canvas_camera.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "save_temporary_camera_position.png")))
        self.btn_save_obj_canvas_camera.triggered.connect(self.save_obj_canvas_camera)
        self.btn_save_obj_canvas_camera.setEnabled(False)
        self.obj_toolbar.addAction(self.btn_save_obj_canvas_camera)

        self.btn_load_obj_canvas_camera = QtWidgets.QAction("Set camera to saved position.", self)
        self.btn_load_obj_canvas_camera.setIcon(QtGui.QIcon(os.path.join(self.icon_dir, "set_temporary_camera_position.png")))
        self.btn_load_obj_canvas_camera.triggered.connect(self.load_obj_canvas_camera)
        self.btn_load_obj_canvas_camera.setEnabled(False)
        self.obj_toolbar.addAction(self.btn_load_obj_canvas_camera)

        self.obj_renderer = gfx.WgpuRenderer(self.obj_canvas, pixel_ratio=1)
        self.obj_renderer.add_event_handler(self.save_camera_view, "key_down")
        self.obj_scene = gfx.Scene()
        self.obj_stats = gfx.Stats(viewport=self.obj_renderer)

        self.background = gfx.Background(None, gfx.BackgroundMaterial([1, 1, 1, 1]))
        self.obj_scene.add(self.background)
        
        self.img_plane_grp = gfx.Group()
        self.obj_scene.add(self.img_plane_grp)

        self.cam_planes_grp = gfx.Group()
        self.obj_scene.add(self.cam_planes_grp)

        self.cam_lines_grp = gfx.Group()
        self.obj_scene.add(self.cam_lines_grp)
        
        #fov of the camera appaars to represent the vertical FOV!
        self.obj_camera = gfx.PerspectiveCamera(fov=45, depth_range=(1, 100000))
        
        
        self.obj_canvas.request_draw()

        self.obj_controller = OrbitFlightController(self.obj_camera, speed=2500, register_events=self.obj_renderer, damping=0)
        self.img_controller = ImageController(self.obj_camera, register_events=self.obj_renderer, damping=0)
        self.img_controller.enabled = False

        self.list_toolbar = QtWidgets.QToolBar()
        self.list_toolbar.setIconSize(QtCore.QSize(20, 20))
        
        self.img_list = QtWidgets.QListWidget()
        self.img_list.setContextMenuPolicy(3)   #call customContextMenu
        self.img_list.setAlternatingRowColors(True)
        self.img_list.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.img_list.itemClicked.connect(self.camera_clicked)
        self.img_list.customContextMenuRequested.connect(self.show_image_menu)
        
        self.prev_img_item = None
        
        self.split_canvas = QtWidgets.QSplitter()
        split_max_width = QtWidgets.QApplication.primaryScreen().size().width()
        
        self.img_split = QtWidgets.QWidget()
        img_split_layout = QtWidgets.QVBoxLayout()
        img_split_layout.setSpacing(0)
        img_split_layout.setContentsMargins(0, 0, 0, 0)
        img_split_layout.addWidget(self.img_toolbar)
        img_split_layout.addWidget(self.img_canvas)
        img_split_layout.addWidget(self.img_statusbar)
        self.img_split.setLayout(img_split_layout)
        
        self.obj_split = QtWidgets.QWidget()
        obj_split_layout = QtWidgets.QVBoxLayout()
        obj_split_layout.setSpacing(0)
        obj_split_layout.setContentsMargins(0, 0, 5, 0)
        obj_split_layout.addWidget(self.obj_toolbar)
        obj_split_layout.addWidget(self.obj_canvas)
        obj_split_layout.addWidget(self.obj_statusbar)
        self.obj_split.setLayout(obj_split_layout)
        
        self.split_canvas.addWidget(self.img_split)
        self.split_canvas.addWidget(self.obj_split)
        self.split_canvas.setSizes([split_max_width, split_max_width])
        
        self.list_widget = QtWidgets.QWidget()
        self.list_widget.setMinimumSize(QtCore.QSize(150, 16777215))
        self.list_widget.setMaximumSize(QtCore.QSize(150, 16777215))
        list_widget_layout = QtWidgets.QVBoxLayout()
        list_widget_layout.setSpacing(0)
        list_widget_layout.setContentsMargins(0, 16, 0, 0)
        list_widget_layout.addWidget(self.list_toolbar)
        list_widget_layout.addWidget(self.img_list)
        self.list_widget.setLayout(list_widget_layout)
        
        main_layout = QtWidgets.QHBoxLayout()
        main_layout.setSpacing(0)
        main_layout.setContentsMargins(5, 0, 5, 0)
        main_layout.addWidget(self.split_canvas)
        main_layout.addWidget(self.list_widget)

        layout = QtWidgets.QVBoxLayout()
        layout.setSpacing(0)
        layout.setContentsMargins(0, 0, 0, 5)
        layout.setMenuBar(self.menu)
        layout.addWidget(self.main_toolbar)
        layout.addLayout(main_layout)
        self.setLayout(layout)
        
        self.img_context_menu = QtWidgets.QMenu(self)
        self.img_context_menu_align = QtGui.QAction('Align 3D view with camera view', self)
        self.img_context_menu_align.triggered.connect(self.align_view)
        self.img_context_menu.addAction(self.img_context_menu_align)
        
        # self.img_context_menu_ortho = QtGui.QAction('Generate orthophoto', self)
        # self.img_context_menu_ortho.triggered.connect(self.show_orthophoto_dlg)
        # self.img_context_menu.addAction(self.img_context_menu_ortho)


        self.sel_gid = None
        self.obj_camera_state = None
        self.obj_camera_origin = None
        self.origin_memory = []

        self.json_check = False
        self.map_check = False

        self.cam_dict = {}
        self.cam_list = []
        self.first_toggle = True
        self.active_camera = None


    def open_help_window(self):
        webbrowser.open_new("https://github.com/smfloery/moniQue")


    def save_camera_view(self, event):
        if event.key == "F1":
            
            curr_cam = self.obj_camera.get_state()                                    
            (canvas_h, canvas_w) = self.obj_canvas.get_logical_size()
            
            #https://github.com/pygfx/pygfx/blob/dc443c4b6356cdd276c1cbfdab1b15d2142a07dc/pygfx/cameras/_perspective.py#L291
            #it appars that the vfov and hfov are somehow manipulated to maintain aspect; Directly using them in separate
            #rendering leads to completely different extents; By adjusting it in that way, inspired by the above link, 
            #its somehow similar to what was seen in the scene --> not applied anymore
            # vfov = np.deg2rad(curr_cam["fov"])
            # hfov = vfov*(canvas_w/canvas_h)#*(canvas_w/canvas_h) #second multiplication to correct for aspect ratio maintenance
            # vfov *= (1 / (canvas_h / canvas_w))
            
            #through the maintain_aspect=True of the camera it appaers that the view is so adjusted as if hfov is equal to vfov; At least using these settings
            #leads to the best render results in monique-helper; Only empirically tested; I have no idea why but it does somehow make sense?
            #therefore we only use "fov" in the output json
            vfov = np.deg2rad(curr_cam["fov"])
            # hfov = vfov
            
            cam_pos = self.obj_camera.local.position + self.min_xyz
            cam_rmat_pygfx = self.obj_camera.local.rotation_matrix[:3, :3]  #already transposed in contrast to self.obj_camera.view_matrix; otherweise the same
            alzekas = rot2alzeka(cam_rmat_pygfx)
            
            if self.active_camera is not None:
                width = self.active_camera.img_w
                height = self.active_camera.img_h
                name = self.active_camera.iid
            else:
                width = None
                height = None
                name = "unknown"
                        
            cam_dict = {name: {"project":self.gpkg_path,
                               "X0":cam_pos[0],
                               "Y0":cam_pos[1],
                               "Z0":cam_pos[2],
                               "alpha":alzekas[0, 0],
                               "zeta":alzekas[0, 1],
                               "kappa":alzekas[0, 2],
                               "fov":vfov,
                               "img_w":width,
                               "img_h":height
                               }
                        }
            
                        
            json_path = QtWidgets.QFileDialog.getSaveFileName(None, "JSON path", name if name is not "unknown" else "", ("Json (*.json)"))[0]
            if json_path:
                json_cam = json.dumps(cam_dict, indent=4, ensure_ascii=False).encode("utf-8")
                with open(json_path, "w", encoding="utf-8") as json_file:
                    json_file.write(json_cam.decode(encoding="utf-8"))
    
    def set_layers(self, lyr_dict):
        self.reg_lyr = lyr_dict["reg_lyr"]
        self.cam_lyr = lyr_dict["cam_lyr"]        
        self.img_lyr = None                     #will be set layer when terrestrial image is loaded
        
        self.img_line_lyr = lyr_dict["img_line_lyr"]
        self.map_line_lyr = lyr_dict["map_line_lyr"]
        
        self.img_gcps_lyr = lyr_dict["img_gcps_lyr"]
        self.map_gcps_lyr = lyr_dict["map_gcps_lyr"]
        
        self.img_gcps_gid_ix = self.img_gcps_lyr.dataProvider().fieldNameIndex('gid')
        
        self.map_gcps_gid_ix = self.map_gcps_lyr.dataProvider().fieldNameIndex('gid')
        self.map_gcps_lyr_obj_x_ix = self.map_gcps_lyr.dataProvider().fieldNameIndex('obj_x')
        self.map_gcps_lyr_obj_y_ix = self.map_gcps_lyr.dataProvider().fieldNameIndex('obj_y')
        self.map_gcps_lyr_obj_z_ix = self.map_gcps_lyr.dataProvider().fieldNameIndex('obj_z')
        
        #define layers which should be shown/considered in which canvas
        self.img_canvas.setLayers([self.img_line_lyr, self.img_gcps_lyr])
        self.img_canvas.setMapTool(self.img_pan_tool)
        
        self.mono_tool.set_layers(self.img_line_lyr, self.map_line_lyr)
        self.mono_select_tool.set_layers(self.img_line_lyr, self.map_line_lyr)
        self.mono_vertex_tool.set_layers(self.img_line_lyr, self.map_line_lyr)
        
    def show_dlg_create(self):
        json_path = QtWidgets.QFileDialog.getOpenFileName(None, "Open project", "", ("Geopackage (*.json)"))[0]
        if json_path:
            self.create_gpkg_from_json(json_path)
    
    def create_gpkg_from_json(self, json_path):
        gpkg_path = json_path.replace(".json", ".gpkg")
                
        QtWidgets.QApplication.instance().setOverrideCursor(QtCore.Qt.WaitCursor)
        transform_context = QgsProject.instance().transformContext() #necessary for writing
                
        with open(json_path, "r") as f:
            tiles_data = json.load(f)
            minx, miny, minz = tiles_data["min_xyz"]
            maxx, maxy, maxz = tiles_data["max_xyz"]
            crs = "EPSG:%s" % (tiles_data["epsg"])
            
        mesh_bbox = [QgsPointXY(minx, maxy),
                     QgsPointXY(maxx, maxy),
                     QgsPointXY(maxx, miny),
                     QgsPointXY(minx, miny),
                     QgsPointXY(minx, maxy)]
            
        reg_lyr = QgsVectorLayer("Polygon?crs=%s" % (crs), "region", "memory")
        pr = reg_lyr.dataProvider()
        pr.addAttributes([QgsField("name", QtCore.QVariant.String), 
                          QgsField("json_path", QtCore.QVariant.String),
                          QgsField("minx", QtCore.QVariant.Double, "double", 10, 3), 
                          QgsField("miny", QtCore.QVariant.Double, "double", 10, 3),
                          QgsField("minz", QtCore.QVariant.Double, "double", 10, 3),
                          QgsField("maxx", QtCore.QVariant.Double, "double", 10, 3), 
                          QgsField("maxy", QtCore.QVariant.Double, "double", 10, 3),
                          QgsField("maxz", QtCore.QVariant.Double, "double", 10, 3)])
        reg_lyr.updateFields() 
            
        # add a feature
        feat = QgsFeature()
        feat.setGeometry(QgsGeometry.fromPolygonXY([mesh_bbox]))
        feat.setAttributes([os.path.basename(gpkg_path).split(".")[0], 
                            json_path,
                            float(minx), 
                            float(miny), 
                            float(minz), 
                            float(maxx),
                            float(maxy),
                            float(maxz)])
        pr.addFeatures([feat])

        # update layer's extent when new features have been added
        # because change of extent in provider is not propagated to the layer
        reg_lyr.updateExtents()
        
        #write region layer to geopackage
        lyr_options = QgsVectorFileWriter.SaveVectorOptions()
        lyr_options.layerName = reg_lyr.name()
        lyr_options.driverName = "GPKG"
        
        if hasattr(QgsVectorFileWriter, 'writeAsVectorFormatV3'): #for QGIS Version >3.20
            use_v3 = True
            _writer = QgsVectorFileWriter.writeAsVectorFormatV3(reg_lyr, gpkg_path, transform_context, lyr_options)
        elif hasattr(QgsVectorFileWriter, 'writeAsVectorFormatV2'): #for QGIS Version <3.20
            use_v3 = False
            _writer = QgsVectorFileWriter.writeAsVectorFormatV2(reg_lyr, gpkg_path, transform_context, lyr_options)
            
        if _writer[0] == QgsVectorFileWriter.NoError:
            pass
        else:
            self.msg_bar.pushMessage("Error", "Could not create project.", level=Qgis.Critical, duration=3)
            raise ValueError("Could not create project!")
                            
        #create additionally needed layers and add them to the geopackage as well
        cam_lyr = QgsVectorLayer("Point?crs=%s" % (crs), "cameras", "memory")
        cam_pr = cam_lyr.dataProvider()
        cam_pr.addAttributes([QgsField("iid", QtCore.QVariant.String),
                              QgsField("path", QtCore.QVariant.String),
                              QgsField("ext", QtCore.QVariant.String),
                              QgsField("is_oriented", QtCore.QVariant.Int),
                              QgsField("obj_x0", QtCore.QVariant.Double, "double", 10, 3),
                              QgsField("obj_y0", QtCore.QVariant.Double, "double", 10, 3),
                              QgsField("obj_z0", QtCore.QVariant.Double, "double", 10, 3),
                              QgsField("obj_x0_std", QtCore.QVariant.Double, "double", 10, 3),
                              QgsField("obj_y0_std", QtCore.QVariant.Double, "double", 10, 3),
                              QgsField("obj_z0_std", QtCore.QVariant.Double, "double", 10, 3),
                              QgsField("alpha", QtCore.QVariant.Double, "double", 10, 5),
                              QgsField("zeta", QtCore.QVariant.Double, "double", 10, 3),
                              QgsField("kappa", QtCore.QVariant.Double, "double", 10, 5),
                              QgsField("alpha_std", QtCore.QVariant.Double, "double", 10, 3),
                              QgsField("zeta_std", QtCore.QVariant.Double, "double", 10, 5),
                              QgsField("kappa_std", QtCore.QVariant.Double, "double", 10, 3),
                              QgsField("s0", QtCore.QVariant.Double, "double", 10, 1),
                              QgsField("img_x0", QtCore.QVariant.Double, "double", 10, 1),
                              QgsField("img_y0", QtCore.QVariant.Double, "double", 10, 1),
                              QgsField("f", QtCore.QVariant.Double, "double", 10, 1),
                              QgsField("f_std", QtCore.QVariant.Double, "double", 10, 1),
                              QgsField("img_w", QtCore.QVariant.Int),
                              QgsField("img_h", QtCore.QVariant.Int),
                              QgsField("hfov", QtCore.QVariant.Double, "double", 6, 3),
                              QgsField("vfov", QtCore.QVariant.Double, "double", 6, 3)])
        cam_lyr.updateFields() 
                
        gcps_lyr = QgsVectorLayer("Point?crs=%s" % (crs), "gcps", "memory")
        gcps_pr = gcps_lyr.dataProvider()
        gcps_pr.addAttributes([QgsField("iid", QtCore.QVariant.String),
                              QgsField("gid", QtCore.QVariant.String),
                              QgsField("desc", QtCore.QVariant.String),
                              QgsField("obj_x", QtCore.QVariant.Double, "double", 10, 3),
                              QgsField("obj_y", QtCore.QVariant.Double, "double", 10, 3),
                              QgsField("obj_z", QtCore.QVariant.Double, "double", 10, 3),
                              QgsField("obj_x_std", QtCore.QVariant.Double, "double", 10, 3),
                              QgsField("obj_y_std", QtCore.QVariant.Double, "double", 10, 3),
                              QgsField("obj_z_std", QtCore.QVariant.Double, "double", 10, 3),
                              QgsField("active", QtCore.QVariant.String)])
        gcps_lyr.updateFields() 
        
        gcps_img_lyr = QgsVectorLayer("Point?crs=%s" % (crs), "gcps_img", "memory")
        gcps_img_pr = gcps_img_lyr.dataProvider()
        gcps_img_pr.addAttributes([QgsField("iid", QtCore.QVariant.String),
                              QgsField("gid", QtCore.QVariant.String),
                              QgsField("desc", QtCore.QVariant.String),
                              QgsField("img_x", QtCore.QVariant.Double, "double", 10, 1),
                              QgsField("img_y", QtCore.QVariant.Double, "double", 10, 1),
                              QgsField("img_dx", QtCore.QVariant.Double, "double", 10, 1),
                              QgsField("img_dy", QtCore.QVariant.Double, "double", 10, 1),
                              QgsField("active", QtCore.QVariant.String)])
        gcps_img_lyr.updateFields()
                
        map_line_lyr = QgsVectorLayer("LineString?crs=%s" % (crs), "lines", "memory")
        map_line_pr = map_line_lyr.dataProvider()
        map_line_pr.addAttributes([QgsField("iid", QtCore.QVariant.String), 
                                   QgsField("type", QtCore.QVariant.String), 
                                   QgsField("comment", QtCore.QVariant.String)]);
        map_line_lyr.updateFields() 
        
        map_line_pnts_lyr = QgsVectorLayer("Point?crs=%s" % (crs), "lines_vx", "memory")
        
        img_line_lyr = QgsVectorLayer("LineString", "lines_img", "memory")
        img_line_pr = img_line_lyr.dataProvider()
        img_line_pr.addAttributes([QgsField("iid", QtCore.QVariant.String), 
                                   QgsField("type", QtCore.QVariant.String), 
                                   QgsField("comment", QtCore.QVariant.String)]);
        img_line_lyr.updateFields() 
        
        img_line_pnts_lyr = QgsVectorLayer("Point", "lines_img_vx", "memory")
        
        lyrs = [map_line_lyr, cam_lyr, map_line_pnts_lyr, img_line_lyr, img_line_pnts_lyr, gcps_lyr, gcps_img_lyr]              
        
        for lyr in lyrs:
            options = QgsVectorFileWriter.SaveVectorOptions()
            options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer    
            options.layerName = lyr.name()
            options.driverName = "GPKG"
            
            if use_v3: #QGIS < 3.20
                _writer = QgsVectorFileWriter.writeAsVectorFormatV3(lyr, gpkg_path, transform_context, options)
            else:
                _writer = QgsVectorFileWriter.writeAsVectorFormatV2(lyr, gpkg_path, transform_context, options)
            
            if _writer[0] == QgsVectorFileWriter.NoError:
                pass
            else:
                pass
        
        QtWidgets.QApplication.instance().restoreOverrideCursor()

        self.load_project(gpkg_path=gpkg_path)
    
    def show_dlg_orient(self):
        if self.btn_ori_tool.isChecked() or self.json_check == True:
            self.dlg_orient = OrientDialog(parent=self, icon_dir=self.icon_dir, active_iid=self.active_camera.iid)

            self.dlg_orient.gcp_selected_signal.connect(self.select_gcp)
            self.dlg_orient.gcp_deselected_signal.connect(self.deselect_gcp)
            self.dlg_orient.gcp_delete_signal.connect(self.delete_gcp)
            self.dlg_orient.gcp_imported_signal.connect(self.save_gcp_to_lyr)
            self.dlg_orient.get_camera_signal.connect(self.get_wpgu_camera)
            self.dlg_orient.camera_estimated_signal.connect(self.process_estimated_camera)
            self.dlg_orient.save_orientation_signal.connect(self.save_orientation_to_lyr)
            self.dlg_orient.activate_mouse_projection_signal.connect(self.toggle_project_mouse_pos)
            self.dlg_orient.deactivate_mouse_projection_signal.connect(self.untoggle_project_mouse_pos)

            self.dlg_orient.add_gcps_from_lyr(self.get_gcps_from_gpkg())

            if self.active_camera.is_oriented == 1:
                self.dlg_orient.set_init_params(self.active_camera.asdict())
                self.dlg_orient.btn_preview_pos.setEnabled(True)
                
            self.dlg_orient.show()
            
            self.btn_mono_select.setEnabled(False)
            self.btn_mono_tool.setEnabled(False)
            self.btn_mono_vertex.setEnabled(False)
            
    def load_project(self, gpkg_path=None):
        if not gpkg_path:
            gpkg_path = QtWidgets.QFileDialog.getOpenFileName(None, "Open project", "", ("Geopackage (*.gpkg)"))[0]
        
        #load dialog could be cancled; hence, gkpk_path must not always be defined
        if gpkg_path:
            self.load_project_signal.emit({"gpkg_path":gpkg_path})
            self.gpkg_path = gpkg_path
            
    def save_project_as(self):
        pass
    
    def closeEvent(self, event):
        
        if self.img_lyr is not None:
            QgsProject.instance().removeMapLayer(self.img_lyr.id())
            self.img_lyr = None
        
        if self.cam_lyr is not None:
            QgsProject.instance().removeMapLayer(self.cam_lyr.id())
            self.cam_lyr = None
        
        if self.img_line_lyr is not None:
            QgsProject.instance().removeMapLayer(self.img_line_lyr.id())
            self.img_line_lyr = None
        
        if self.img_gcps_lyr is not None:
            QgsProject.instance().removeMapLayer(self.img_gcps_lyr.id())
            self.img_gcps_lyr = None
        
        if self.map_line_lyr is not None:
            QgsProject.instance().removeMapLayer(self.map_line_lyr.id())
            self.map_line_lyr = None
        
        if self.map_gcps_lyr is not None:
            QgsProject.instance().removeMapLayer(self.map_gcps_lyr.id())
            self.map_gcps_lyr = None
        
        if self.reg_lyr is not None:
            QgsProject.instance().removeMapLayer(self.reg_lyr.id())
            self.reg_lyr = None
        
        self.img_canvas.refresh()
        self.close_dialog_signal.emit()
    
    def show_img_in_obj_canvas(self):
                
        if self.btn_obj_canvas_show_img.isChecked():    #activate
            
            #if GCP picking is not active show this cursor; otherwise leave the cross hair
            if not self.orient_dlg_open:
                self.obj_canvas.setCursor(QCursor(Qt.SizeVerCursor))           

            self.img_in_obj_check = True

            self.set_obj_canvas_camera(self.temporary_camera)
            
            self.img_list.setEnabled(False)
            self.img_controller.enabled = True
            self.obj_controller.enabled = False
            
            self.btn_mono_tool.setEnabled(False)
            self.btn_mono_select.setEnabled(False)
            self.btn_mono_vertex.setEnabled(False)
            self.btn_ori_tool.setEnabled(False)
            self.btn_obj_canvas_camera_from_map.setEnabled(False)
            self.btn_reset_obj_canvas_camera.setEnabled(False)
            
            img_w = self.active_camera.img_w
            img_h = self.active_camera.img_h
                    
            prc = np.array([self.temporary_camera["obj_x0"], self.temporary_camera["obj_y0"], self.temporary_camera["obj_z0"]]) - self.min_xyz
            rmat = alzeka2rot([self.temporary_camera["alpha"], self.temporary_camera["zeta"], self.temporary_camera["kappa"]])
            cmat = np.array([[1, 0, -self.temporary_camera["img_x0"]], 
                            [0, 1, -self.temporary_camera["img_y0"]],
                            [0, 0, -self.temporary_camera["f"]]])
            
            plane_pnts_img = np.array([[0, 0, 1],
                                [img_w, 0, 1],
                                [img_w, img_h*(-1), 1],
                                [0, img_h*(-1), 1]]).T
            
            plane_pnts_dir = (rmat@cmat@plane_pnts_img).T
            plane_pnts_dir = plane_pnts_dir / np.linalg.norm(plane_pnts_dir, axis=1).reshape(-1, 1)
            
            plane_pnts_obj = prc + 1000 * plane_pnts_dir
            plane_faces = np.array([[3, 1, 0], [3, 2, 1]]).astype(np.uint32)
            plane_uv = np.array([[0, 0], [1, 0], [1, 1], [0, 1]]).astype(np.uint32)
            
            plane_geom = gfx.geometries.Geometry(indices=plane_faces, 
                                                positions=plane_pnts_obj.astype(np.float32),
                                                texcoords=plane_uv.astype(np.float32))
            
            img_path = self.active_camera.path    
            img = Image.open(img_path)
            img_array = np.asarray(img)
            tex = gfx.Texture(img_array, dim=2)
            
            # if gfx.__version__ != '0.7.0':
            #     plane_material = gfx.MeshBasicMaterial(map=tex, side="FRONT", map_interpolation="linear")
            # else:
            plane_material = gfx.MeshBasicMaterial(map=tex, side="FRONT")
                
            plane_mesh = gfx.Mesh(plane_geom, plane_material, visible=True)
            
            self.img_controller.set_image(plane_mesh, plane_pnts_dir, prc, distance=1000)
            
            self.img_plane_grp.clear()
            self.img_plane_grp.add(plane_mesh)

            #hide camera objects in 3D as those intervene with rendering
            # for iid, iid_grp in self.cam_dict.items():
            #     iid_grp.visible = False
            
            self.obj_canvas.request_draw()
            
        else:
            self.img_in_obj_check = False
            
            #only if the orient dialog is not open the image list should be made active again; change back to "normal" cursor
            if not self.orient_dlg_open:
                self.img_list.setEnabled(True)
                self.obj_canvas.setCursor(QCursor(Qt.ArrowCursor))
            else:   #if orient dialog is open change back to cross hair as GCP becomes active again
                self.obj_canvas.setCursor(QCursor(Qt.CrossCursor))

            self.img_controller.enabled = False
            self.obj_controller.enabled = True
            
            self.btn_mono_tool.setEnabled(True)
            self.btn_mono_select.setEnabled(True)
            self.btn_mono_vertex.setEnabled(True)
            self.btn_ori_tool.setEnabled(True)
            self.btn_obj_canvas_camera_from_map.setEnabled(True)
            self.btn_reset_obj_canvas_camera.setEnabled(True)
            
            self.img_plane_grp.clear()
            
            self.obj_canvas.request_draw()

    def create_cam_pos(self):
        for cam_feat in self.cam_lyr.getFeatures():

            if cam_feat['obj_x0'] != None:   
                img_w = int(cam_feat['img_w'])
                img_h = int(cam_feat['img_h'])
                            
                prc = np.array([float(cam_feat["obj_x0"]), float(cam_feat["obj_y0"]), float(cam_feat["obj_z0"])]) - self.min_xyz
                rmat = alzeka2rot([float(cam_feat["alpha"]), float(cam_feat["zeta"]), float(cam_feat["kappa"])])
                cmat = np.array([[1, 0, -float(cam_feat["img_x0"])], 
                                [0, 1, -float(cam_feat["img_y0"])],
                                [0, 0, -float(cam_feat["f"])]])
                        
                plane_pnts_img = np.array([[0, 0, 1],
                                        [img_w, 0, 1],
                                        [img_w, img_h*(-1), 1],
                                        [0, img_h*(-1), 1]]).T
                        
                plane_pnts_dir = (rmat@cmat@plane_pnts_img).T
                plane_pnts_dir = plane_pnts_dir / np.linalg.norm(plane_pnts_dir, axis=1).reshape(-1, 1)
                        
                plane_pnts_obj = prc + 500 * plane_pnts_dir
                plane_faces = np.array([[3, 1, 0], [3, 2, 1]]).astype(np.uint32)
                plane_uv = np.array([[0, 0], [1, 0], [1, 1], [0, 1]]).astype(np.uint32)
                        
                plane_geom = gfx.geometries.Geometry(indices=plane_faces, 
                                                    positions=plane_pnts_obj.astype(np.float32),
                                                    texcoords=plane_uv.astype(np.float32))
                        
                plane_material = gfx.MeshBasicMaterial(color = (1, 0.65, 0, 1), opacity=0.5)
                plane_mesh = gfx.Mesh(plane_geom, plane_material, visible=True)

                self.img_controller.set_image(plane_mesh, plane_pnts_dir, prc, distance=1000)
                    
                positions = [[list(prc),plane_pnts_obj[i]] for i in range(4)]
                lines = [gfx.Line(gfx.Geometry(positions=positions[i]), gfx.LineMaterial(thickness=1.0, color=(1, 0.65, 0.0), opacity=1)) for i in range(4)]

                self.add_cam_pos_to_obj_canvas(cam_feat['iid'], plane_mesh, lines)


    def show_cam_pos(self):
            for i in self.cam_dict.keys():
                self.cam_dict[i]['plane'].visible = self.btn_show_cam_pos.isChecked()
                self.cam_dict[i]['lines'].visible = self.btn_show_cam_pos.isChecked()
                
            self.obj_canvas.request_draw()

    def repaint_cam_pos(self, current_iid, sel_check):
        try:
            if sel_check:
                for i in self.cam_dict[current_iid]['plane'].children:
                    i.material = gfx.MeshBasicMaterial(color = (1, 0, 0, 1), opacity=0.5)
                for i in self.cam_dict[current_iid]['lines'].children:
                    i.material = gfx.LineMaterial(thickness=1.0, color=(1, 0, 0), opacity=1)
                
            else:
                for i in self.cam_dict[current_iid]['plane'].children:
                    i.material = gfx.MeshBasicMaterial(color = (1, 0.65, 0, 1), opacity=0.5)
                for i in self.cam_dict[current_iid]['lines'].children:
                    i.material = gfx.LineMaterial(thickness=1.0, color=(1, 0.65, 0), opacity=1)
            
            self.obj_canvas.request_draw()
        
        except:
            print('Image has no orientation!')

    def update_cam_pos(self, current_iid):
        for cam_feat in self.cam_lyr.getFeatures():
            if cam_feat['iid'] == current_iid:
                if cam_feat['obj_x0'] != None:   
                    img_w = int(cam_feat['img_w'])
                    img_h = int(cam_feat['img_h'])
                                
                    prc = np.array([float(cam_feat["obj_x0"]), float(cam_feat["obj_y0"]), float(cam_feat["obj_z0"])]) - self.min_xyz
                    rmat = alzeka2rot([float(cam_feat["alpha"]), float(cam_feat["zeta"]), float(cam_feat["kappa"])])
                    cmat = np.array([[1, 0, -float(cam_feat["img_x0"])], 
                                    [0, 1, -float(cam_feat["img_y0"])],
                                    [0, 0, -float(cam_feat["f"])]])
                            
                    plane_pnts_img = np.array([[0, 0, 1],
                                            [img_w, 0, 1],
                                            [img_w, img_h*(-1), 1],
                                            [0, img_h*(-1), 1]]).T
                            
                    plane_pnts_dir = (rmat@cmat@plane_pnts_img).T
                    plane_pnts_dir = plane_pnts_dir / np.linalg.norm(plane_pnts_dir, axis=1).reshape(-1, 1)
                            
                    plane_pnts_obj = prc + 500 * plane_pnts_dir
                    plane_faces = np.array([[3, 1, 0], [3, 2, 1]]).astype(np.uint32)
                    plane_uv = np.array([[0, 0], [1, 0], [1, 1], [0, 1]]).astype(np.uint32)
                            
                    plane_geom = gfx.geometries.Geometry(indices=plane_faces, 
                                                        positions=plane_pnts_obj.astype(np.float32),
                                                        texcoords=plane_uv.astype(np.float32))
                            
                    plane_material = gfx.MeshBasicMaterial(color = (1, 0.65, 0, 1), opacity=0.5)
                    plane_mesh = gfx.Mesh(plane_geom, plane_material, visible=True)

                    self.img_controller.set_image(plane_mesh, plane_pnts_dir, prc, distance=1000)
                        
                    positions = [[list(prc),plane_pnts_obj[i]] for i in range(4)]
                    lines = [gfx.Line(gfx.Geometry(positions=positions[i]), gfx.LineMaterial(thickness=1.0, color=(1, 0.65, 0.0), opacity=1)) for i in range(4)]

                    try:
                        self.cam_dict[current_iid]['plane'].clear()
                        self.cam_dict[current_iid]['lines'].clear()
                    except:
                        pass

                    self.add_cam_pos_to_obj_canvas(cam_feat['iid'], plane_mesh, lines)
                    
                    self.obj_canvas.request_draw()
        

    def add_cam_pos_to_obj_canvas(self, iid, plane_mesh, lines):
        self.cam_dict[iid] = {'plane':gfx.Group(visible=False), 'lines':gfx.Group(visible=False)}
        
        self.cam_dict[iid]['plane'].add(plane_mesh)

        for i in lines:
            self.cam_dict[iid]['lines'].add(i)

        self.obj_scene.add(self.cam_dict[iid]['plane'])
        self.obj_scene.add(self.cam_dict[iid]['lines'])


    def add_mesh_to_obj_canvas(self, tiles_data):
        
        self.tiles_data = tiles_data
        
        self.msg_box = QtWidgets.QProgressDialog("Loading tiles...", None, 0, len(self.tiles_data["tiles"])+1, self)
        self.msg_box.setWindowTitle("%s" % (self.parent.project_name))
        self.msg_box.setWindowModality(QtCore.Qt.WindowModal)
        self.msg_box.show()
        self.msg_box.setValue(0)
        QtWidgets.QApplication.processEvents()  #required otherwise msg_box stays empty and is not updated; found here: https://stackoverflow.com/questions/47879413/pyqt-qprogressdialog-displays-as-an-empty-white-window
                
        self.terrain = gfx.Group()
        self.min_xyz = np.array(self.tiles_data["min_xyz"])
        self.max_xyz = np.array(self.tiles_data["max_xyz"])

        self.create_cam_pos()
        
        self.o3d_scene = o3d.t.geometry.RaycastingScene()
        
        for tx, tile in enumerate(self.tiles_data["tiles"]):
            
            self.msg_box.setValue(tx+1)
            
            geom_path = os.path.normpath(os.path.join(self.tiles_data["tile_dir"], "%s.ply" % (tile["tid"])))
            # op_path = os.path.normpath(os.path.join(self.tiles_data["op_dir"], "%s.jpg" % (tile["tid"])))
            op_paths = glob.glob(os.path.normpath(os.path.join(self.tiles_data["op_dir"], "%s.*" % (tile["tid"]))))
                        
            if len(op_paths) == 1:
                op_path = op_paths[0]            
            else:
                op_path = None     
                        
            if os.path.exists(geom_path):
                
                tile_mesh = o3d.io.read_triangle_mesh(geom_path)
                verts = np.asarray(tile_mesh.vertices).astype(np.float32)
                
                u = (verts[:, 0] - tile["min_xyz"][0])/(tile["max_xyz"][0] - tile["min_xyz"][0])
                v = (verts[:, 1] - tile["min_xyz"][1])/(tile["max_xyz"][1] - tile["min_xyz"][1])
                uv = np.hstack((u.reshape(-1, 1), v.reshape(-1, 1)))
                
                verts -= self.min_xyz
                faces = np.asarray(tile_mesh.triangles).astype(np.uint32)
                
                self.o3d_scene.add_triangles(verts, faces)
                                    
                # print("Loading mesh...")
                mesh_geom = gfx.geometries.Geometry(indices=faces, 
                                                    positions=verts,
                                                    texcoords=uv.astype(np.float32),
                                                    tid=[int(tile["tid_int"])])
                if op_path is not None:
                    if os.path.exists(op_path):
                        img_ds = gdal.Open(op_path)
                        img_h = img_ds.RasterYSize
                        img_w = img_ds.RasterXSize
                        img_arr = np.zeros((img_h, img_w, 3), dtype=np.uint8)
                                    
                        for bx in range(3):
                            bx_arr = img_ds.GetRasterBand(bx+1).ReadAsArray()
                            img_arr[:, :, bx] = bx_arr
                                        
                        img_arr = np.flipud(img_arr)
                        tex = gfx.Texture(img_arr, dim=2, generate_mipmaps=True)

                        mesh_material = gfx.MeshBasicMaterial(map=tex, side="FRONT", pick_write=True)
                    else:
                        mesh_material = gfx.MeshNormalMaterial(side="FRONT", pick_write=True)
                else:
                    mesh_material = gfx.MeshNormalMaterial(side="FRONT", pick_write=True)
            
                #add lowest resolution material to mesh at startup
                mesh = gfx.Mesh(mesh_geom, mesh_material, visible=False)
                mesh.add_event_handler(self.zoom_to_point, "click")
                self.terrain.add(mesh)
            
        self.obj_scene.add(self.terrain)
        local_cx = self.tiles_data["cx"] - self.min_xyz
                
        offset_z = local_cx[0] / np.tan(np.deg2rad(self.obj_camera.get_state()["fov"])/2)
        
        self.obj_camera.local.position = local_cx + np.array([0, 0, offset_z])
        self.obj_camera.show_pos(local_cx)
        
        self.default_obj_camera_state = copy.deepcopy(self.obj_camera.get_state())
        
        #intitial render call
        self.msg_box.setLabelText("Rendering initial scene...")
        QtWidgets.QApplication.processEvents()
        self.obj_canvas.request_draw(self.animate)  #request draw calls animate     
        
        #group that will hold all the GCPs on object space
        self.obj_gcps_grp = gfx.Group()
        self.obj_scene.add(self.obj_gcps_grp)
        
        self.obj_scene.add(gfx.AmbientLight(intensity=1), gfx.DirectionalLight())
                
        self.mono_tool.set_minxyz(self.min_xyz)
        self.mono_vertex_tool.set_minxyz(self.min_xyz)
                       
        self.mono_tool.set_scene(self.o3d_scene)
        self.mono_vertex_tool.set_scene(self.o3d_scene)
    
    def animate(self): 
        cam_state = self.obj_camera.get_state()
        self.obj_status_fov_edit.setText("%.1f" % (cam_state["fov"]))
        
        if self.tiles_data is not None:
                        
            # cam_pos = self.obj_camera.local.position
            frustum = self.obj_camera.frustum
            corners_flat = frustum.reshape((-1, 3))
                    
            corners_by_plane = np.stack([
                corners_flat[[0, 3, 7, 4], :],
                corners_flat[[5, 6, 2, 1], :],
                corners_flat[[3, 2, 6, 7], :],
                corners_flat[[4, 5, 1, 0], :],
                corners_flat[[1, 2, 3, 0], :],
                corners_flat[[4, 7, 6, 5], :]], axis=0)
                        
            # planes in normal form (normals point away from the frustum area)
            normals = np.cross(
                corners_by_plane[:, 0, :] - corners_by_plane[:, 3, :],
                corners_by_plane[:, 2, :] - corners_by_plane[:, 3, :]
            )
            
            normals /= np.linalg.norm(normals, axis=-1)[:, None] # normal normals ^_^
            # offset = np.sum(normals * corners_by_plane[:, 3, :], axis=-1)  #d=n*r0; r0 some point on the plane            
            
            # end_time = time.time()
            # print("%.6f" % (end_time - start_time))
            
            # start_time = time.time()
            for tile in self.tiles_data["tiles"]:
                result = "INSIDE"
                tile_cx = np.array(tile["cx_r"][:3]) - self.min_xyz
                
                for nx in range(6):
                    
                    #normal distance between any point on the plane and the sphere center                
                    #https://www.w3schools.blog/distance-of-a-point-from-a-plane
                    #simplest frustum culling technique; renderes more tiles than actually visible;
                    cx_c_vec = tile_cx - corners_by_plane[nx, 0, :]                    
                    cx_dist = np.dot(cx_c_vec, normals[nx, :])
                                    
                    if cx_dist > tile["cx_r"][-1]:
                        result="OUTSIDE"
                        break
                                    
                # #first tile added to group has tid_pygfx = 0; Hence, we can use this id to directly access the 
                # #respective children within the list; no need for an additional for loop;
                if result == "INSIDE":
                    self.terrain.children[int(tile["tid_int"])].visible = True
                else:
                    self.terrain.children[int(tile["tid_int"])].visible = False
                    
            self.obj_renderer.render(self.obj_scene, self.obj_camera, flush=True) #flash=True if fps not used anymore
            
            if self.initial_render is True:
                self.msg_box.setValue(len(self.tiles_data["tiles"])+1)
                QtWidgets.QApplication.instance().restoreOverrideCursor()
                self.initial_render = False        
            
            
              
    def import_images(self):
        """Import selected images.
        """       
        img_paths = QtWidgets.QFileDialog.getOpenFileNames(None, "Load images", "", ("Image (*.tif *.tiff *.png *.jpg *.jpeg)"))[0]
        loaded_imgs = [self.img_list.item(x).text() for x in range(self.img_list.count())]
        
        for path in img_paths:
            [img_name, img_ext] = os.path.basename(path).rsplit(".", 1)
            
            if img_name not in loaded_imgs:
                
                img = Image.open(path)
                img_h = img.height
                img_w = img.width
                                
                cam = Camera(iid=img_name, path=path, ext=img_ext, is_oriented=False, img_h=img_h, img_w=img_w)
                self.camera_collection[cam.iid] = cam
                
                self.add_camera_to_list(cam)
                self.add_camera_to_cam_lyr(cam)

    def import_json(self):
        """Import position and orientation from selected JSON.
        """

        json_path = QtWidgets.QFileDialog.getOpenFileName(None, "Import position/orientation from json", "", ("JSON (*.json)"))[0]

        try: 
            self.appr_cam_pos = jsonImport(json_path)
        except:
            print("Provided JSON does not appear to be valid.")
            return
        
        try:    
            cam_pos = self.appr_cam_pos.get_pos()[self.active_camera.iid]
            cam_ori = self.appr_cam_pos.get_ori()[self.active_camera.iid]

            data = {"obj_x0":cam_pos['X0'], "obj_y0":cam_pos['Y0'], "obj_z0":cam_pos['Z0'], 
                    "alpha":cam_ori['alpha'], "zeta":cam_ori['beta'], "kappa":cam_ori['gamma'],
                    "img_x0":self.active_camera.img_w/2., "img_y0":self.active_camera.img_h/2.*(-1), "f":np.sqrt(self.active_camera.img_w**2 + self.active_camera.img_h**2)}
            
            self.json_check = True

            self.show_dlg_orient()
            self.dlg_orient.set_init_params(data)
            self.process_estimated_camera(data)

            self.json_check = False

        except:
            print("Something went wrong while setting the initial camera parameters! \nPlease check if an image has been selected and try again.")
            self.json_check = False
            return   
                 
    def get_gcps_from_gpkg(self):
        gcps = OrderedDict()
        gcp_data = {"obj_x":None, "obj_y":None, "obj_z":None, "img_x":None, "img_y":None, "img_dx":None, "img_dy":None, "active":None}
        
        for feat in self.img_gcps_lyr.getFeatures():
            curr_gcp = gcp_data.copy()
            img_gcp = json.loads(QgsJsonUtils.exportAttributes(feat))
            
            curr_gid = img_gcp["gid"]
            
            curr_gcp["img_x"] = img_gcp["img_x"]
            curr_gcp["img_y"] = img_gcp["img_y"]
            curr_gcp["img_dx"] = img_gcp["img_dx"]
            curr_gcp["img_dy"] = img_gcp["img_dy"]
            curr_gcp["active"] = img_gcp["active"]
            
            gcps[curr_gid] = curr_gcp
        
        for feat in self.map_gcps_lyr.getFeatures():
            map_gcp = json.loads(QgsJsonUtils.exportAttributes(feat))
            curr_gid = map_gcp["gid"]
            
            if curr_gid in gcps.keys():
                gcps[curr_gid]["obj_x"] = map_gcp["obj_x"]
                gcps[curr_gid]["obj_y"] = map_gcp["obj_y"]
                gcps[curr_gid]["obj_z"] = map_gcp["obj_z"]
            else:
                curr_gcp = gcp_data.copy()
                curr_gcp["obj_x"] = map_gcp["obj_x"]
                curr_gcp["obj_y"] = map_gcp["obj_y"]
                curr_gcp["obj_z"] = map_gcp["obj_z"]
                curr_gcp["active"] = map_gcp["active"]
                
                gcps[curr_gid] = curr_gcp

        return gcps
    
    def select_gcp(self, data):
        self.sel_gid = data["gid"]
        self.map_gcps_lyr.selectByExpression("\"gid\"=%s"%(data["gid"]))
        self.img_gcps_lyr.selectByExpression("\"gid\"=%s"%(data["gid"]))
        
        for pnts in self.obj_gcps_grp.children:
            if int(data["gid"]) == int(pnts.geometry.gid.data[0]):
                pnts.material = gfx.PointsMaterial(color=(1, 0.98, 0, 1), size=10)
            else:
                pnts.material = gfx.PointsMaterial(color=(0.78, 0, 0, 1), size=10)
        
        self.obj_canvas.request_draw()
    
    def deselect_gcp(self):
        self.sel_gid = None
        self.map_gcps_lyr.removeSelection()
        self.img_gcps_lyr.removeSelection()

        for pnts in self.obj_gcps_grp.children:
            pnts.material = gfx.PointsMaterial(color=(0.78, 0, 0, 1), size=10)
        
        self.obj_canvas.request_draw()
        
    def delete_gcp(self, data):
        if self.map_gcps_lyr.selectedFeatureCount() > 0:
            self.map_gcps_lyr.startEditing()
            self.map_gcps_lyr.deleteSelectedFeatures() 
            self.map_gcps_lyr.commitChanges()
        
        if self.img_gcps_lyr.selectedFeatureCount() > 0:
            self.img_gcps_lyr.startEditing()
            self.img_gcps_lyr.deleteSelectedFeatures()
            self.img_gcps_lyr.commitChanges()

        del_gcp_obj = None
        for gcp_obj in self.obj_gcps_grp.children:
            if int(data["gid"]) == int(gcp_obj.geometry.gid.data[0]):
                del_gcp_obj = gcp_obj
                
        if del_gcp_obj:
            self.obj_gcps_grp.remove(del_gcp_obj)
            self.obj_canvas.request_draw()
            
    def add_camera_to_list(self, camera):
        """Add camera to the image list.

        Args:
            camera (_type_): Camera object.
        """
        
        item = QtWidgets.QListWidgetItem(camera.iid)
        item.setSizeHint(QtCore.QSize(24, 24))
        item.setFlags(item.flags() ^ QtCore.Qt.ItemIsUserCheckable)
        item.setCheckState(QtCore.Qt.Unchecked)
        self.img_list.addItem(item)

    def add_camera_to_cam_lyr(self, camera):
        """Add camera to the camera GPKG layer.

        Args:
            camera (_type_): Camera object.
        """
        feat = QgsFeature(self.cam_lyr.fields())
        feat["iid"] = camera.iid
        feat["path"] = camera.path
        feat["ext"] = camera.ext
        feat["img_w"] = camera.img_w
        feat["img_h"] = camera.img_h
        
        pr = self.cam_lyr.dataProvider()
        pr.addFeatures([feat])
                
        self.cam_lyr.commitChanges()

    def uncheck_list_items(self, item):
        for ix in range(self.img_list.count()):
            
            curr_item = self.img_list.item(ix)
            
            if (curr_item != item) & (curr_item.checkState() == QtCore.Qt.Checked):
                curr_item.setCheckState(QtCore.Qt.Unchecked)

    def load_img(self, iid, path):
        img_lyr = QgsRasterLayer(path, iid)
                
        if not img_lyr.isValid():
            self.msg_bar.pushCritical("Error", "Could not load %s!" % (path))
        else:
            if self.img_lyr is not None:
                QgsProject.instance().removeMapLayer(self.img_lyr.id())
            
            self.img_lyr = img_lyr
                
            # QgsProject.instance().addMapLayer(self.img_lyr, False) #False --> do not add layer to LayerTree --> not visible in qgis main canvas
            self.img_canvas.setExtent(self.img_lyr.extent())
            self.img_canvas.setLayers([self.img_gcps_lyr, self.img_line_lyr, self.img_lyr])
            self.img_canvas.refresh()
            
    def set_img_canvas_extent(self):
        self.img_canvas.setExtent(self.img_lyr.extent())
        self.img_canvas.refresh()
    
    def get_wpgu_camera(self):
        
        cam_pos = self.obj_camera.local.position + self.min_xyz

        #the camera appears to be exactly what alzeka needs; hence, we can directly derive alzeka from the rotation matrix
        cam_rmat_pygfx = self.obj_camera.local.rotation_matrix[:3, :3]  #already transposed in contrast to self.obj_camera.view_matrix; otherweise the same
        alzekas = rot2alzeka(cam_rmat_pygfx)
                
        data = {"obj_x0":cam_pos[0], "obj_y0":cam_pos[1], "obj_z0":cam_pos[2], 
                "alpha":alzekas[0, 0], "zeta":alzekas[0, 1], "kappa":alzekas[0, 2],
                "img_x0":self.active_camera.img_w/2., "img_y0":self.active_camera.img_h/2.*(-1), "f":np.sqrt(self.active_camera.img_w**2 + self.active_camera.img_h**2)}
        
        self.dlg_orient.set_init_params(data)
    
    def process_estimated_camera(self, data):
        
        est_hfov = calc_hfov(self.active_camera.img_w, data["f"])
        est_vfov = calc_vfov(self.active_camera.img_h, data["f"])
        data["hfov"] = est_hfov
        data["vfov"] = est_vfov
        
        self.set_obj_canvas_camera(data)
        self.btn_obj_canvas_show_img.setEnabled(True)
                
        if self.json_check == False:
            self.update_camera(data)
            self.update_gcps(data)
        
    def update_camera(self, data):
        curr_cam = list(self.cam_lyr.getFeatures(expression = "iid = '%s'" % (self.active_camera.iid)))[0]
        curr_cam_fid = curr_cam.id()
        
        self.cam_lyr.startEditing()
        
        self.cam_lyr.changeGeometry(curr_cam_fid, QgsGeometry.fromPoint(QgsPoint(data["obj_x0"], data["obj_y0"])))
        self.cam_lyr.changeAttributeValue(curr_cam_fid, curr_cam.fieldNameIndex("is_oriented"), 1)
        
        attrs = ["obj_x0", "obj_y0", "obj_z0", "alpha", "zeta", "kappa", "img_x0", "img_y0", "f", "hfov", "vfov"]
        for attr in attrs:
            self.cam_lyr.changeAttributeValue(curr_cam_fid, curr_cam.fieldNameIndex(attr), float(data[attr]))
        
        attrs = ["obj_x0_std", "obj_y0_std", "obj_z0_std", "alpha_std", "zeta_std", "kappa_std", "f_std"]
        for attr in attrs:
            self.cam_lyr.changeAttributeValue(curr_cam_fid, curr_cam.fieldNameIndex(attr), float(data[attr]) if attr in list(data.keys()) else None)
        
        self.cam_lyr.triggerRepaint()

        self.update_cam_pos(self.active_camera.iid)
    
    def update_gcps(self, data):
        curr_img_gcps = self.img_gcps_lyr.getFeatures(expression = "iid = '%s'" % (self.active_camera.iid))
        curr_map_gcps = self.map_gcps_lyr.getFeatures(expression = "iid = '%s'" % (self.active_camera.iid))
        
        used_gids = list(data["residuals"].keys())
        
        self.img_gcps_lyr.startEditing()
        self.map_gcps_lyr.startEditing()
        for gcp in curr_img_gcps:
            
            gcp_gid = str(gcp.attribute("gid"))
            gcp_fid = gcp.id()
                
            if gcp_gid in used_gids:
                self.img_gcps_lyr.changeAttributeValue(gcp_fid, gcp.fieldNameIndex("img_dx"), float(data["residuals"][gcp_gid][0]))
                self.img_gcps_lyr.changeAttributeValue(gcp_fid, gcp.fieldNameIndex("img_dy"), float(data["residuals"][gcp_gid][1]))
                self.img_gcps_lyr.changeAttributeValue(gcp_fid, gcp.fieldNameIndex("active"), "1")
            else:
                self.img_gcps_lyr.changeAttributeValue(gcp_fid, gcp.fieldNameIndex("img_dx"), None)
                self.img_gcps_lyr.changeAttributeValue(gcp_fid, gcp.fieldNameIndex("img_dy"), None)
                self.img_gcps_lyr.changeAttributeValue(gcp_fid, gcp.fieldNameIndex("active"), "0")
        
        for gcp in curr_map_gcps:
            
            gcp_gid = str(gcp.attribute("gid"))
            gcp_fid = gcp.id()
            
            if gcp_gid in used_gids:
                self.map_gcps_lyr.changeAttributeValue(gcp_fid, gcp.fieldNameIndex("active"), "1")        
                for pnts in self.obj_gcps_grp.children:
                    if int(gcp_fid) == int(pnts.geometry.gid.data[0]):
                        pnts.material = gfx.PointsMaterial(color=(0.76, 0, 0, 1), size=10)        
            else:
                self.map_gcps_lyr.changeAttributeValue(gcp_fid, gcp.fieldNameIndex("active"), "0")
                for pnts in self.obj_gcps_grp.children:
                    if int(gcp_fid) == int(pnts.geometry.gid.data[0]):
                        pnts.material = gfx.PointsMaterial(color=(0.87, 0.87, 0.87, 1), size=10)       
    
    def save_gcp_to_lyr(self, data):
        img_feat_geom = QgsPoint(data["img_x"], data["img_y"])
        
        img_feat = QgsFeature(self.img_gcps_lyr.fields())
        img_feat.setGeometry(img_feat_geom)
        img_feat.setAttribute("iid", self.active_camera.iid)
        img_feat.setAttribute("gid", data["gid"])
        img_feat.setAttribute("img_x", data["img_x"])
        img_feat.setAttribute("img_y", data["img_x"])
        img_feat.setAttribute("desc", "")
        img_feat.setAttribute("active", 1)
        
        map_feat = QgsFeature(self.map_gcps_lyr.fields())
        map_feat.setGeometry(QgsPoint(data["obj_x"], data["obj_y"]))
        map_feat["iid"] = self.active_camera.iid
        map_feat["gid"] = data["gid"]
        map_feat["obj_x"] = data["obj_x"]
        map_feat["obj_y"] = data["obj_y"]
        map_feat["obj_z"] = data["obj_z"]
        map_feat["desc"] = ""
        map_feat["active"] = 1
        
        _ = self.map_gcps_lyr.dataProvider().addFeatures([map_feat])
        _ = self.img_gcps_lyr.dataProvider().addFeatures([img_feat])
                
        self.map_gcps_lyr.commitChanges()                      
        self.img_gcps_lyr.commitChanges()
        
        self.map_gcps_lyr.triggerRepaint()
        self.img_gcps_lyr.triggerRepaint() 
    
    def save_orientation_to_lyr(self):
        self.cam_lyr.commitChanges()
        self.img_gcps_lyr.commitChanges()
        self.map_gcps_lyr.commitChanges()
        
        cam_feat = list(self.cam_lyr.getFeatures(expression = "iid = '%s'" % (self.active_camera.iid)))[0]
        cam_feat_json = json.loads(QgsJsonUtils.exportAttributes(cam_feat))
        
        del cam_feat_json["fid"]
        cam = Camera(**cam_feat_json)

        self.camera_collection[cam.iid] = cam
        self.active_camera = self.camera_collection[cam.iid]
        self.update_cam_pos(cam.iid)
        
    def discard_changes(self):
        self.img_gcps_lyr.rollBack()
        self.map_gcps_lyr.rollBack()
        self.cam_lyr.rollBack()
         
    def set_obj_canvas_camera(self, data):
        self.obj_camera.local.position = np.array([data["obj_x0"], data["obj_y0"], data["obj_z0"]]) - self.min_xyz
        
        photo_rmat = alzeka2rot([data["alpha"], data["zeta"], data["kappa"]])
        pygfx_rmat = np.zeros((4,4))
        pygfx_rmat[3, 3] = 1
        pygfx_rmat[:3, :3] = photo_rmat
            
        self.obj_camera.local.rotation_matrix = pygfx_rmat
        
        #we add 5 degrees as border
        if data["hfov"] >= data["vfov"]:
            self.obj_camera.fov = np.rad2deg(data["hfov"])+5
        else:
            self.obj_camera.fov = np.rad2deg(data["hfov"]*(data["vfov"]/data["hfov"]))+5

        prc = np.array([data["obj_x0"], data["obj_y0"], data["obj_z0"]])
        rmat = alzeka2rot([data["alpha"], data["zeta"], data["kappa"]])
        kmat = np.array([[-data["f"], 0, data["img_x0"]], 
                        [0, -data["f"], data["img_y0"]],
                        [0, 0, 1]])
        pmat = kmat@rmat.T@np.hstack((np.eye(3), -prc.reshape(3, 1)))
        data["pmat"] = pmat
        
        self.temporary_camera = data
        self.obj_canvas.request_draw()

    def reset_obj_canvas_camera(self):
        self.obj_camera.set_state(self.default_obj_camera_state)
        self.obj_canvas.request_draw()
            
    def save_obj_canvas_camera(self):
        self.obj_camera_state = None
        self.obj_camera_state = copy.deepcopy(self.obj_camera.get_state())
    
    def load_obj_canvas_camera(self):
        if self.obj_camera_state is None:
            pass
        else:
            self.obj_camera.set_state(self.obj_camera_state)
            self.obj_canvas.request_draw()

    def coord_transform(self, point):
        geom = QgsGeometry.fromPointXY(point)
        sourceCRS = QgsCoordinateReferenceSystem(iface.mapCanvas().mapSettings().destinationCrs().authid())
        targetCRS = QgsCoordinateReferenceSystem(self.cam_lyr.crs())
        tr = QgsCoordinateTransform(sourceCRS, targetCRS, QgsProject.instance())
        geom.transform(tr)
        return geom.asPoint()
    
    def obj_canvas_camera_from_map(self):
        try:
            map_pos = self.coord_transform(iface.mapCanvas().center())
            map_extent = iface.mapCanvas().extent()

            map_width = map_extent.xMaximum() - map_extent.xMinimum()
            map_height = map_extent.yMaximum() - map_extent.yMinimum()
            
            map_z = map_width/np.tan(45/2)
            if map_z < self.min_xyz[2]:
                map_z = self.min_xyz[2]

            min_xy = np.array([self.min_xyz[0], self.min_xyz[1], 0])
            map_pos_loc = np.array([map_pos.x(), map_pos.y(), map_z]) - min_xy

            obj_camera_target = {'position':map_pos_loc,
                                        'rotation':np.array([0.,0.,0.,1.]), 
                                        'scale':np.array([1.,1.,1.]),
                                        'reference_up':np.array([0.,0.,1.]), 
                                        'fov':45.0, 
                                        'width':map_width, 
                                        'height':map_height, 
                                        'zoom':1.0, 
                                        'maintain_aspect':True,
                                        'depth_range':(1, 1000000)}
            
            self.obj_camera.set_state(obj_camera_target)
            self.obj_camera.show_pos((map_pos_loc[0], map_pos_loc[1], self.min_xyz[2]), up=(0,0,1))
            self.obj_canvas.request_draw()#self.animate)

        except:
            print('No project seems to be loaded!')

    # def export_obj_canvas(self):
    #     try:
    #         def_res = [str(self.active_camera.img_w), str(self.active_camera.img_h)]
    #     except:
    #         def_res = ['1920','1080']

    #     def_name = self.parent.project_name

    #     export_dialog = ExportMetaDialog(def_res, def_name)
    #     export_dialog.exec_()
    #     depth_set = False

    #     if export_dialog.ok == True:
    #         export_path = QtWidgets.QFileDialog.getExistingDirectory(self)
    #     else:
    #         export_path=''

    #     if len(export_path) > 0:
    #         resolution = [int(export_dialog.res_width.text()), int(export_dialog.res_height.text())]
            
    #         offscreen_canvas = offscreenCanvas(size=(resolution[0], resolution[1]), pixel_ratio=1)
    #         offscreen_renderer = gfx.WgpuRenderer(offscreen_canvas)

    #         if export_dialog.depth_offset.text() == '':
    #             pass
    #         else:
    #             if int(export_dialog.depth_offset.text()) > 0:
    #                 depth_set = True  
    #                 curr_depth = self.obj_camera.depth_range
    #                 self.obj_camera.depth_range = (int(export_dialog.depth_offset.text()), curr_depth[1])
    #             else:
    #                 pass

    #         for pnts in self.obj_gcps_grp.children:
    #             pnts.visible = False

    #         bg = gfx.Background(None, gfx.BackgroundMaterial([0.086, 0.475, 0.671, 1]))
    #         self.obj_scene.remove(self.background)
    #         self.obj_scene.add(bg)

    #         offscreen_canvas.request_draw(offscreen_renderer.render(self.obj_scene, self.obj_camera))
    #         img = Image.fromarray(np.asarray(offscreen_canvas.draw()))
    #         img.save(os.path.join(export_path, export_dialog.file_name.text() + "_render.png"))

    #         self.obj_scene.remove(bg)
    #         self.obj_scene.add(self.background)

    #         for pnts in self.obj_gcps_grp.children:
    #             pnts.visible = True

    #         if depth_set:
    #             self.obj_camera.depth_range = (curr_depth[0], curr_depth[1])
        
    #     else:
    #         pass
        
    def show_image_menu(self, point):
        clicked_list_item = self.img_list.itemAt(point.x(), point.y())
        
        self.img_context_menu.setTitle(clicked_list_item.text())
        
        
        for action in self.img_context_menu.actions():
            if self.camera_collection[clicked_list_item.text()].is_oriented == 1:
                action.setEnabled(True)
            else:
                action.setEnabled(False)
        
        
        self.img_context_menu.exec(self.img_list.mapToGlobal(point))
    
    def align_view(self):
        self.set_obj_canvas_camera(self.camera_collection[self.img_context_menu.title()].asdict())
    
    def show_orthophoto_dlg(self):
        pass
    
    def camera_clicked(self, item):
        
        if item.isSelected():
            if item == self.prev_img_item:
                self.untoggle_camera(item)
                self.prev_img_item = None
            else:
                self.toggle_camera(item)
                self.prev_img_item = item

    def untoggle_camera(self, item):
        
        self.btn_ori_tool.setEnabled(False)
        self.btn_mono_tool.setEnabled(False)
        self.btn_mono_select.setEnabled(False)
        self.btn_mono_vertex.setEnabled(False)
        self.btn_obj_canvas_show_img.setEnabled(False)
        
        item.setCheckState(QtCore.Qt.Unchecked)
        self.img_list.clearSelection()
        
        self.obj_gcps_grp.clear()        
        self.img_plane_grp.clear()
        self.obj_canvas.request_draw()
        
        self.btn_obj_canvas_show_img.setChecked(False)
        self.btn_obj_canvas_show_img.setEnabled(False)
        
        expression = "iid = 'some_crap_that_doesnt_exist'"
        self.img_line_lyr.setSubsetString(expression)
        self.img_gcps_lyr.setSubsetString(expression)
        self.map_gcps_lyr.setSubsetString(expression)
        
        self.img_canvas.setLayers([])
        self.img_canvas.refresh()        
        
        self.active_camera = None
        self.setWindowTitle("%s" % (self.project_name))

        iid = item.text()
        self.repaint_cam_pos(iid, False)
        
    def toggle_camera(self, item):
        
        self.btn_ori_tool.setEnabled(True)
        
        item.setCheckState(QtCore.Qt.Checked)
        self.uncheck_list_items(item)
                    
        iid = item.text()
        iid_path = self.camera_collection[iid].path
                
        if not os.path.exists(iid_path):
            
            while True:
                new_iid_path = QFileDialog.getOpenFileName(self, "Image not found! Please, specfiy new path.", "", ("Image (*.tif *.tiff *.png *.jpg *.jpeg)"))[0]

                if new_iid_path is "":
                    break
                
                if os.path.exists(new_iid_path):
                    break
            
            if new_iid_path is not "":
            
                self.camera_collection[iid].set_path(new_iid_path)
                field_idx = self.cam_lyr.fields().indexOf('path')
                
                for feat in self.cam_lyr.getFeatures():
                    if feat['iid'] == iid:
                        feature_id = feat.id()
                        self.cam_lyr.startEditing()
                        self.cam_lyr.changeAttributeValue(feature_id,field_idx,new_iid_path)
                        self.cam_lyr.commitChanges()

                iid_path = new_iid_path
            else:
                return
        
        self.load_img(iid, iid_path)
        
        expression = "iid = '%s'" % (iid)
        self.img_line_lyr.setSubsetString(expression) #show only those lines which correspond to the currently selected image
        self.img_gcps_lyr.setSubsetString(expression)
        self.map_gcps_lyr.setSubsetString(expression)

        self.active_camera = self.camera_collection[iid]
        self.setWindowTitle("%s - %s" % (self.project_name, iid))
        
        #remove all children from the group --> removes all prevously loaded GCPs
        self.obj_gcps_grp.clear()
        
        for gcp in self.map_gcps_lyr.getFeatures():
            gcp_pos = [gcp["obj_x"]-self.min_xyz[0], 
                        gcp["obj_y"]-self.min_xyz[1], 
                        gcp["obj_z"]-self.min_xyz[2]]
            
            if gcp["active"] == '1':
                gcp_clr = (0.78, 0, 0, 1)
            else:
                gcp_clr = (0.86, 0.86, 0.86, 1)
            
            gcp_gfx = create_point_3d(gcp_pos, gcp["gid"], gcp_clr)
            self.obj_gcps_grp.add(gcp_gfx)

        if self.active_camera.is_oriented == 1:
                        
            self.btn_mono_tool.setEnabled(True)
            self.btn_mono_select.setEnabled(True)
            self.btn_mono_vertex.setEnabled(True)
            self.btn_obj_canvas_show_img.setEnabled(True)
            self.temporary_camera = self.camera_collection[iid].asdict()
                            
            self.mono_tool.set_camera(self.active_camera)
            self.mono_vertex_tool.set_camera(self.active_camera)
        else:
            self.btn_mono_tool.setEnabled(False)
            self.btn_mono_select.setEnabled(False)
            self.btn_mono_vertex.setEnabled(False)
            self.btn_obj_canvas_show_img.setEnabled(False)
            # self.btn_obj_canvas_show_img.setEnabled(False)

        if self.first_toggle:
            self.first_toggle = False
        else:
            self.repaint_cam_pos(self.prior_iid, False)

        self.repaint_cam_pos(iid, True)
        self.obj_canvas.request_draw()

        self.prior_iid = iid   
        
    def toggle_mono_tool(self):
        if self.btn_mono_tool.isChecked():                  #activate
            self.btn_ori_tool.setEnabled(False)
            self.btn_mono_select.setEnabled(False)
            self.btn_mono_vertex.setEnabled(False)
            #during monoplotting user cant adjust image orientation            
            self.img_canvas.setMapTool(self.mono_tool)
            self.img_list.setEnabled(False)
            self.mono_tool.reset()
        else:                                               #deactivate
            self.btn_ori_tool.setEnabled(True)
            self.btn_mono_select.setEnabled(True)
            self.btn_mono_vertex.setEnabled(True)
            self.img_list.setEnabled(True)
            self.img_canvas.unsetMapTool(self.mono_tool)
            self.img_canvas.setMapTool(self.img_pan_tool)
    
    def toggle_mono_select_tool(self):
        if self.btn_mono_select.isChecked():              #activate tool
                        
            self.btn_ori_tool.setEnabled(False)
            self.btn_mono_tool.setEnabled(False)
            self.btn_mono_vertex.setEnabled(False)
            self.img_list.setEnabled(False)
            
            #during monoplotting user cant adjust image orientation
            self.img_canvas.setMapTool(self.mono_select_tool)
            self.mono_select_tool.reset()
        else:
            self.btn_ori_tool.setEnabled(True)
            self.btn_mono_tool.setEnabled(True)#deactivate tool
            self.btn_mono_select.setEnabled(True)
            self.btn_mono_vertex.setEnabled(True)
            self.img_list.setEnabled(True)
            self.img_canvas.unsetMapTool(self.mono_select_tool)
            self.img_canvas.setMapTool(self.img_pan_tool)    
    
    def toggle_mono_vertex_tool(self):
        if self.btn_mono_vertex.isChecked():              #activate tool
            
            self.btn_ori_tool.setEnabled(False)
            self.btn_mono_tool.setEnabled(False)
            self.btn_mono_select.setEnabled(False)
            self.img_list.setEnabled(False)
            self.img_list.setEnabled(True)
            #during monoplotting user cant adjust image orientation
            self.img_canvas.setMapTool(self.mono_vertex_tool)
            self.mono_vertex_tool.reset()
        else:                                           #deactivate tool
            self.btn_ori_tool.setEnabled(True)
            self.btn_mono_tool.setEnabled(True)
            self.btn_mono_select.setEnabled(True)
            self.btn_mono_vertex.setEnabled(True)
            
            self.img_canvas.unsetMapTool(self.mono_vertex_tool)
            self.img_canvas.setMapTool(self.img_pan_tool)    
    
    def activate_gui_elements(self):
        self.img_list.setEnabled(True)
        self.img_menu.setEnabled(True)
        # self.export_menu.setEnabled(True)
        # self.view_menu.setEnabled(True)
        self.btn_reset_obj_canvas_camera.setEnabled(True)
        self.btn_obj_canvas_camera_from_map.setEnabled(True)
        self.btn_show_cam_pos.setEnabled(True)
        self.btn_save_obj_canvas_camera.setEnabled(True)
        self.btn_load_obj_canvas_camera.setEnabled(True)
        self.project_name = self.windowTitle()

    def activate_gcp_picking(self):

        #GCP picking in image space
        self.img_picker_tool = ImgPickerTool(self.img_canvas, GcpMetaDialog())
        self.img_picker_tool.set_camera(self.active_camera)
        self.img_picker_tool.set_layers(img_gcps_lyr=self.img_gcps_lyr, map_gcps_lyr=self.map_gcps_lyr)
        
        self.img_picker_tool.gcpAdded.connect(self.img_gcp_added)
        self.img_picker_tool.gcpEdit.connect(self.gcp_selected)
        self.img_picker_tool.gcpUpdated.connect(self.img_gcp_updated)
        self.img_picker_tool.gcpUpdated.connect(self.deselect_gcp)
        
        self.img_canvas.setMapTool(self.img_picker_tool)
        
        #GCP picking ib object space
        for mesh in self.terrain.children:
            mesh.add_event_handler(self.mesh_picking, "click")
    
    def gcp_selected(self, data):
        self.dlg_orient.gcp_selected(data, 1)

    def deactivate_gcp_picking(self):
        for mesh in self.terrain.children:
            mesh.remove_event_handler(self.mesh_picking, "click")
        self.img_canvas.setMapTool(self.img_pan_tool)
        
    def img_gcp_added(self, data):
        self.dlg_orient.add_gcp_to_table(data, gcp_type="img_space")
    
    def img_gcp_updated(self, data):
        self.dlg_orient.update_selected_gcp(data, gcp_type="img_space")
    
    def pick_to_world(self, event):
        face_ix = event.pick_info["face_index"]
            
        #face_coords are not normalized; hence, divide by their sum first before using the further
        face_coords = np.array(event.pick_info["face_coord"]).reshape(3, 1) 
        face_coords /= np.sum(face_coords)
        
        face_vertex_ix = event.pick_info["world_object"].geometry.indices.data[face_ix, :]
        face_vertex_pos = event.pick_info["world_object"].geometry.positions.data[face_vertex_ix, :]
        
        click_pos = np.sum(face_vertex_pos*face_coords, axis=0) 
        click_pos_global = click_pos + self.min_xyz
        return click_pos, click_pos_global
    
    def mesh_picking(self, event):
                
        if event.button == 1 and "Control" in event.modifiers:
                       
            click_pos_local, click_pos_global = self.pick_to_world(event)
            
            feat_geom = QgsPoint(click_pos_global[0], click_pos_global[1])

            if self.map_gcps_lyr.selectedFeatureCount() > 0:
                sel_fid = self.map_gcps_lyr.selectedFeatureIds()[0]
                self.map_gcps_lyr.startEditing()
                self.map_gcps_lyr.changeGeometry(sel_fid, QgsGeometry.fromPoint(feat_geom))
                self.map_gcps_lyr.changeAttributeValue(sel_fid, self.map_gcps_lyr_obj_x_ix, float(click_pos_global[0]))
                self.map_gcps_lyr.changeAttributeValue(sel_fid, self.map_gcps_lyr_obj_y_ix, float(click_pos_global[1]))
                self.map_gcps_lyr.changeAttributeValue(sel_fid, self.map_gcps_lyr_obj_z_ix, float(click_pos_global[2]))
                self.map_gcps_lyr.commitChanges()
                
                for pnts in self.obj_gcps_grp.children:
                    if int(self.sel_gid) == int(pnts.geometry.gid.data[0]):
                        pnts.geometry.positions.data[0, :] = click_pos_local                                      #update point geometry position
                        pnts.geometry.positions.update_range(0)
                        pnts.children[0].local.position = pnts.geometry.positions.data[0, :] + [0, 0, 10]   #update position of label
                        break
                    
                self.obj_canvas.request_draw()
                self.dlg_orient.update_selected_gcp({"obj_x":click_pos_global[0],
                                                     "obj_y":click_pos_global[1],
                                                     "obj_z":click_pos_global[2]}, gcp_type="obj_space")
                
                self.img_gcps_lyr.removeSelection()
                self.deselect_gcp()

            else:
                
                dlg_meta = GcpMetaDialog()
                
                img_gids = [feat.attributes()[self.img_gcps_gid_ix] for feat in self.img_gcps_lyr.getFeatures()]
                map_gids = [feat.attributes()[self.map_gcps_gid_ix] for feat in self.map_gcps_lyr.getFeatures()]
                pot_gids = list(set(img_gids).difference(map_gids))
                    
                dlg_meta.combo_gid.addItems(pot_gids)
                
                dlg_meta.line_iid.setText(self.active_camera.iid)
                
                dlg_meta.line_obj_x.setText("%.1f" % (click_pos_global[0]))
                dlg_meta.line_obj_y.setText("%.1f" % (click_pos_global[1]))
                dlg_meta.line_obj_z.setText("%.1f" % (click_pos_global[2]))
                
                dlg_meta.gids_not_allowed = map_gids
                
                result = dlg_meta.exec_() 

                if result:
                    
                    curr_gid = dlg_meta.combo_gid.currentText() 
                    gcp_clr = (0.78, 0, 0, 1)
                    
                    click_obj = create_point_3d(click_pos_local, curr_gid, gcp_clr)
                    self.obj_gcps_grp.add(click_obj)
                    self.obj_canvas.request_draw()
                    
                    self.dlg_orient.add_gcp_to_table({"obj_x":click_pos_global[0], 
                                                      "obj_y":click_pos_global[1],
                                                      "obj_z":click_pos_global[2],
                                                      "gid":curr_gid},
                                                    gcp_type="obj_space")
                    
                    feat = QgsFeature(self.map_gcps_lyr.fields())
                    
                    feat.setGeometry(QgsPoint(click_pos_global[0], click_pos_global[1]))
                    feat.setAttribute("iid", self.active_camera.iid)
                    feat.setAttribute("gid", dlg_meta.combo_gid.currentText())
                    feat.setAttribute("obj_x", float(click_pos_global[0]))
                    feat.setAttribute("obj_y", float(click_pos_global[1]))
                    feat.setAttribute("obj_z", float(click_pos_global[2]))
                    feat.setAttribute("desc", dlg_meta.line_desc.text())
                    feat.setAttribute("active", 0)
                    (res, afeat) = self.map_gcps_lyr.dataProvider().addFeatures([feat])
                    self.map_gcps_lyr.commitChanges()
                    self.map_gcps_lyr.triggerRepaint()

        if event.button == 1 and "Alt" in event.modifiers:
            click_pos_local, _ = self.pick_to_world(event)
            mx = click_pos_local[0] + self.min_xyz[0]
            my = click_pos_local[1] + self.min_xyz[1]
            mz = click_pos_local[2] + self.min_xyz[2]

            gcp_dict = {}
            for feat in self.map_gcps_lyr.getFeatures():
                gcp_dict[feat['gid']] = (feat['obj_x'], feat['obj_y'], feat['obj_z'])

            dist = [np.sqrt((mx-gcp_dict[i][0])**2 + (my-gcp_dict[i][1])**2 + (mz-gcp_dict[i][2])**2) for i in gcp_dict.keys()]
            rix = dist.index(min(dist))

            if dist[rix] < 100:
                self.gcp_selected(rix)

    def zoom_to_point(self, event):
        
        #only conduct zoom to point if image is not currently shown in the object canvas
        if not self.btn_obj_canvas_show_img.isChecked():
        
            if event.button == 2 and "Control" in event.modifiers:
    
                click_pos_local, _ = self.pick_to_world(event)
                
                self.obj_camera_origin = copy.deepcopy(self.obj_camera.get_state())
                self.origin_memory.append(self.obj_camera_origin)

                vektor = [click_pos_local[0] - self.obj_camera_origin['position'][0], click_pos_local[1] - self.obj_camera_origin['position'][1], click_pos_local[2] - self.obj_camera_origin['position'][2]]
                position = [self.obj_camera_origin['position'][0] + vektor[0]/1.05, self.obj_camera_origin['position'][1] + vektor[1]/1.05, self.obj_camera_origin['position'][2] + vektor[2]/1.05]

                self.obj_camera_target = {'position':np.array([position[0], position[1], position[2]]),
                                            'rotation':self.obj_camera_origin['rotation'], 
                                            'scale':self.obj_camera_origin['scale'],
                                            'reference_up':self.obj_camera_origin['reference_up'], 
                                            'fov':self.obj_camera_origin['fov'], 
                                            'width':self.obj_camera_origin['width'], 
                                            'height':self.obj_camera_origin['height'], 
                                            'zoom':self.obj_camera_origin['zoom'], 
                                            'maintain_aspect':self.obj_camera_origin['maintain_aspect'],
                                            'depth_range':self.obj_camera_origin['depth_range']}
                self.obj_camera.set_state(self.obj_camera_target)

                self.obj_camera.show_pos((click_pos_local[0], click_pos_local[1], click_pos_local[2]), up=(0,0,1))
                
                self.obj_canvas.request_draw()
                
            if event.button == 2 and "Alt" in event.modifiers:
                if len(self.origin_memory) > 0:
                    self.obj_camera.set_state(self.origin_memory[-1])
                    self.origin_memory.pop(-1)
                    self.obj_canvas.request_draw()
                else:
                    pass

    def toggle_project_mouse_pos(self):
        self.project_pos_toggled = True
        
        #rubber band for storing reprojected poin from 3d canvas into image
        self.img_rubber = QgsRubberBand(self.img_canvas, Qgis.GeometryType.Point)
        self.img_rubber.setIcon(1)
        self.img_rubber.setColor(QColor(252,15,192, 255))
        self.img_rubber.setIconSize(15)
        
        for mesh in self.terrain.children:
            mesh.add_event_handler(self.reproject_pos, "pointer_move")
    
    def untoggle_project_mouse_pos(self):       
        if self.project_pos_toggled:
            for mesh in self.terrain.children:
                mesh.remove_event_handler(self.reproject_pos, "pointer_move")
            self.project_pos_toggled = False
            self.img_rubber.reset()
            
    def reproject_pos(self, event):
        _, click_pos_global = self.pick_to_world(event)
        
        click_pos_img_hom = self.temporary_camera["pmat"]@np.append(click_pos_global.ravel(), values=1)
        click_pos_img = click_pos_img_hom[:2] / click_pos_img_hom[-1]
        
        #display only if the reprojected point is within the image
        if ((click_pos_img[0] > 0) and (click_pos_img[0] <= self.active_camera.img_w)):
            if (click_pos_img[1] < 0) and (click_pos_img[1] >= self.active_camera.img_h*(-1)):
                self.img_rubber.removeLastPoint()
                self.img_rubber.addPoint(QgsPointXY(click_pos_img[0], click_pos_img[1]))
                self.img_rubber.show()

    # def show_offset_in_obj_canvas(self, offset):
    #     if self.dlg_orient.first_time == True:
    #         self.obj_cam_state = self.obj_camera.get_state()

    #     position = [self.obj_cam_state['position'][0] + offset['offset_x'], 
    #                 self.obj_cam_state['position'][1] + offset['offset_y'], 
    #                 self.obj_cam_state['position'][2] + offset['offset_z']]

    #     obj_camera_target = {'position':np.array([position[0], position[1], position[2]]),
    #                                 'rotation':self.obj_cam_state['rotation'], 
    #                                 'scale':self.obj_cam_state['scale'],
    #                                 'reference_up':self.obj_cam_state['reference_up'], 
    #                                 'fov':self.obj_cam_state['fov'], 
    #                                 'width':self.obj_cam_state['width'], 
    #                                 'height':self.obj_cam_state['height'], 
    #                                 'zoom':self.obj_cam_state['zoom'], 
    #                                 'maintain_aspect':self.obj_cam_state['maintain_aspect'],
    #                                 'depth_range':self.obj_cam_state['depth_range']}
        
    #     self.obj_camera.set_state(obj_camera_target)
    #     self.obj_canvas.request_draw()

